# Phase 4: Headless Mode Automation & Multi-Claude Workflows

## Overview

This phase implements advanced Claude Code automation patterns using headless mode for CI/CD integration and multi-Claude workflows for parallel development. These patterns will dramatically accelerate development velocity and code quality for the experimentation platform.

## Table of Contents

1. [Headless Mode Automation](#1-headless-mode-automation)
2. [Multi-Claude Workflows](#2-multi-claude-workflows)
3. [Implementation Timeline](#implementation-timeline)
4. [Success Metrics](#success-metrics)

---

## 1. Headless Mode Automation

### 1.1 GitHub Issue Triage Automation

**Objective**: Automatically analyze and label new GitHub issues using Claude's understanding of the codebase.

**Implementation Steps**:

1. **Create GitHub Action Workflow** (`.github/workflows/issue-triage.yml`):
   ```yaml
   name: Issue Triage with Claude

   on:
     issues:
       types: [opened]

   jobs:
     triage:
       runs-on: ubuntu-latest
       steps:
         - uses: actions/checkout@v4

         - name: Set up Claude Code
           run: |
             # Install Claude Code CLI
             npm install -g @anthropic-ai/claude-code

         - name: Analyze Issue
           env:
             ANTHROPIC_API_KEY: ${{ secrets.ANTHROPIC_API_KEY }}
             ISSUE_TITLE: ${{ github.event.issue.title }}
             ISSUE_BODY: ${{ github.event.issue.body }}
           run: |
             claude -p "Analyze this issue and suggest appropriate labels based on the codebase.

             Issue Title: ${ISSUE_TITLE}
             Issue Body: ${ISSUE_BODY}

             Available labels:
             - bug: Code defects or unexpected behavior
             - feature: New functionality requests
             - enhancement: Improvements to existing features
             - documentation: Documentation updates
             - backend: Backend/API changes
             - frontend: Frontend/UI changes
             - database: Database schema or migrations
             - testing: Test-related changes
             - performance: Performance optimizations
             - security: Security-related issues

             Return ONLY a JSON array of label names, e.g.: [\"bug\", \"backend\"]
             " --output-format stream-json > labels.json

         - name: Apply Labels
           env:
             GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
           run: |
             LABELS=$(cat labels.json | jq -r '.[]' | tr '\n' ',' | sed 's/,$//')
             gh issue edit ${{ github.event.issue.number }} --add-label "$LABELS"
   ```

2. **Enhanced Triage Script** (`scripts/triage-issue.sh`):
   ```bash
   #!/bin/bash
   # Enhanced issue triage with context awareness

   ISSUE_NUMBER=$1
   ISSUE_DATA=$(gh issue view $ISSUE_NUMBER --json title,body,author)

   claude -p "You are an expert at triaging issues for an experimentation platform.

   Analyze this issue:
   $(echo $ISSUE_DATA | jq -r '.')

   Based on the codebase structure and recent commits, determine:
   1. Issue labels (bug/feature/enhancement/etc.)
   2. Affected components (backend/frontend/lambda/infrastructure)
   3. Priority level (P0-P3)
   4. Estimated complexity (simple/moderate/complex)
   5. Suggested assignee based on code ownership

   Return JSON format:
   {
     \"labels\": [\"label1\", \"label2\"],
     \"components\": [\"backend\", \"database\"],
     \"priority\": \"P1\",
     \"complexity\": \"moderate\",
     \"suggested_assignee\": \"username\",
     \"reasoning\": \"Brief explanation\"
   }
   " --output-format stream-json
   ```

3. **Auto-Comment with Analysis** (`.github/workflows/issue-analysis.yml`):
   ```yaml
   - name: Add Analysis Comment
     run: |
       ANALYSIS=$(claude -p "Analyze issue #${{ github.event.issue.number }}.
       Provide:
       1. Root cause hypothesis
       2. Affected files/components
       3. Suggested investigation steps
       4. Related issues or PRs

       Be concise and actionable." --output-format stream-json)

       gh issue comment ${{ github.event.issue.number }} --body "ðŸ¤– **Automated Analysis**

       $ANALYSIS

       _Generated by Claude Code_"
   ```

**Benefits**:
- Instant issue categorization
- Consistent labeling across the project
- Reduced manual triage time by 80%
- Better issue routing to appropriate team members

---

### 1.2 Claude as a Linter

**Objective**: Implement subjective code quality checks beyond what traditional linters can detect.

**Implementation Steps**:

1. **Create Claude Linter Script** (`scripts/claude-lint.sh`):
   ```bash
   #!/bin/bash
   # Claude Code Linter - Subjective code quality checks

   FILES_TO_CHECK=$@

   if [ -z "$FILES_TO_CHECK" ]; then
     FILES_TO_CHECK=$(git diff --cached --name-only --diff-filter=ACM | grep -E '\.(py|js|ts|tsx)$')
   fi

   if [ -z "$FILES_TO_CHECK" ]; then
     echo "No files to lint"
     exit 0
   fi

   echo "ðŸ” Running Claude Code Linter on:"
   echo "$FILES_TO_CHECK"

   claude -p "Review these files for subjective code quality issues:

   Files: $FILES_TO_CHECK

   Look for:
   1. **Typos in comments, docstrings, and error messages**
   2. **Misleading variable or function names**
   3. **Stale or outdated comments**
   4. **Unclear error messages**
   5. **Missing edge case handling**
   6. **Confusing code organization**
   7. **Inconsistent naming conventions**
   8. **Missing documentation for complex logic**

   For each issue found, provide:
   - File path and line number
   - Issue category
   - Current code snippet
   - Suggested improvement
   - Reasoning

   Return JSON array format:
   [
     {
       \"file\": \"path/to/file.py\",
       \"line\": 42,
       \"category\": \"misleading_name\",
       \"current\": \"def process(x):\",
       \"suggested\": \"def process_user_assignment(user_context):\",
       \"reason\": \"Function name doesn't indicate what it processes; parameter name is unclear\"
     }
   ]

   If no issues found, return empty array: []
   " --output-format stream-json --allowedTools Read Grep > lint-results.json

   # Check results
   ISSUES_COUNT=$(cat lint-results.json | jq '. | length')

   if [ "$ISSUES_COUNT" -gt 0 ]; then
     echo ""
     echo "âš ï¸  Found $ISSUES_COUNT subjective code quality issues:"
     cat lint-results.json | jq -r '.[] | "
   ðŸ“ \(.file):\(.line)
   Category: \(.category)
   Current: \(.current)
   Suggested: \(.suggested)
   Reason: \(.reason)
   "'

     # Don't fail the build, just warn
     echo ""
     echo "ðŸ’¡ Consider addressing these suggestions before committing."
     exit 0
   else
     echo "âœ… No subjective code quality issues found"
     exit 0
   fi
   ```

2. **Pre-commit Hook Integration** (`.git/hooks/pre-commit`):
   ```bash
   #!/bin/bash
   # Pre-commit hook with Claude linter

   echo "Running pre-commit checks..."

   # Run standard linters first
   black --check backend/ || exit 1
   isort --check backend/ || exit 1
   flake8 backend/ || exit 1

   # Run Claude linter (non-blocking)
   if command -v claude &> /dev/null; then
     echo ""
     echo "Running Claude Code linter..."
     ./scripts/claude-lint.sh
   fi
   ```

3. **CI Integration** (`.github/workflows/code-quality.yml`):
   ```yaml
   name: Code Quality with Claude

   on:
     pull_request:
       types: [opened, synchronize]

   jobs:
     subjective-lint:
       runs-on: ubuntu-latest
       steps:
         - uses: actions/checkout@v4
           with:
             fetch-depth: 0  # Get full history for better context

         - name: Get Changed Files
           id: changed-files
           run: |
             CHANGED=$(git diff --name-only origin/${{ github.base_ref }}...HEAD | grep -E '\.(py|js|ts|tsx)$' | tr '\n' ' ')
             echo "files=$CHANGED" >> $GITHUB_OUTPUT

         - name: Run Claude Linter
           if: steps.changed-files.outputs.files != ''
           env:
             ANTHROPIC_API_KEY: ${{ secrets.ANTHROPIC_API_KEY }}
           run: |
             ./scripts/claude-lint.sh ${{ steps.changed-files.outputs.files }}

         - name: Post Review Comments
           if: always()
           run: |
             if [ -f lint-results.json ] && [ $(jq '. | length' lint-results.json) -gt 0 ]; then
               jq -r '.[] | "**\(.file):\(.line)** - \(.category)

               Current: `\(.current)`
               Suggested: `\(.suggested)`

               _Reason: \(.reason)_
               "' lint-results.json > review-comments.md

               gh pr comment ${{ github.event.pull_request.number }} \
                 --body-file review-comments.md
             fi
   ```

**Benefits**:
- Catches subjective issues that ESLint/Flake8 miss
- Improves code readability and maintainability
- Educates developers on better practices
- Non-blocking but highly visible feedback

---

## 2. Multi-Claude Workflows

### 2.1 Code Writing + Verification Workflow

**Objective**: Use separate Claude instances for writing code and reviewing it, leveraging independent context for better results.

**Implementation Pattern**:

1. **Writer Claude** (Terminal 1):
   ```bash
   # Terminal 1: Code Writer
   cd /Users/ashishmarkanday/github/experimentation-platform

   # Task: Implement new feature
   claude
   # Prompt: "Implement metric-based rollback triggers for feature flags.
   # Requirements:
   # - Monitor error rates and latency metrics
   # - Auto-rollback if thresholds exceeded
   # - Comprehensive logging and alerts
   # - Full test coverage"
   ```

2. **Reviewer Claude** (Terminal 2):
   ```bash
   # Terminal 2: Code Reviewer
   cd /Users/ashishmarkanday/github/experimentation-platform
   /clear  # Start fresh context

   # Review the implementation
   claude
   # Prompt: "Review the recent implementation of metric-based rollback triggers.
   # Check for:
   # - Correctness and completeness
   # - Edge cases and error handling
   # - Performance implications
   # - Test coverage
   # - Security considerations
   # - Code quality and maintainability
   #
   # Provide detailed feedback with specific suggestions."
   ```

3. **Implementer Claude** (Terminal 3):
   ```bash
   # Terminal 3: Feedback Implementer
   cd /Users/ashishmarkanday/github/experimentation-platform
   /clear

   # Apply reviewer feedback
   claude
   # Prompt: "Read the code review feedback and the original implementation.
   # Apply the suggested improvements while maintaining functionality.
   # Ensure all tests still pass after changes."
   ```

**Automation Script** (`scripts/multi-claude-workflow.sh`):
```bash
#!/bin/bash
# Multi-Claude Code Review Workflow

FEATURE_BRANCH=$1
SCRATCHPAD_DIR=".claude/scratchpads"

mkdir -p $SCRATCHPAD_DIR

# Step 1: Writer Claude writes code
echo "Step 1: Writer Claude implementing feature..."
claude -p "Implement the feature on branch $FEATURE_BRANCH.
Write your implementation plan to $SCRATCHPAD_DIR/implementation.md
Write any notes or decisions to $SCRATCHPAD_DIR/writer-notes.md" \
--allowedTools Edit Write Bash

# Step 2: Reviewer Claude reviews
echo "Step 2: Reviewer Claude reviewing implementation..."
claude -p "Review the implementation on branch $FEATURE_BRANCH.
Read the writer's notes from $SCRATCHPAD_DIR/writer-notes.md
Write your review feedback to $SCRATCHPAD_DIR/review-feedback.md
Include:
- What works well
- Issues found (with severity: critical/major/minor)
- Specific suggestions for improvement
- Questions for the writer" \
--allowedTools Read Grep

# Step 3: Implementer Claude applies feedback
echo "Step 3: Implementer Claude applying feedback..."
claude -p "Read the review feedback from $SCRATCHPAD_DIR/review-feedback.md
Apply the suggested improvements to the code.
Write a summary of changes to $SCRATCHPAD_DIR/changes-applied.md
Ensure all tests pass after changes." \
--allowedTools Read Edit Bash

echo "Multi-Claude workflow complete. Check scratchpads for details."
```

---

### 2.2 Git Worktrees for Parallel Development

**Objective**: Enable multiple Claude instances to work on independent tasks simultaneously.

**Setup Script** (`scripts/setup-worktrees.sh`):
```bash
#!/bin/bash
# Setup git worktrees for multi-Claude workflows

WORKTREE_BASE="../experimentation-platform-worktrees"
mkdir -p $WORKTREE_BASE

# Function to create a worktree
create_worktree() {
  local task_name=$1
  local branch_name="feature/$task_name"
  local worktree_path="$WORKTREE_BASE/$task_name"

  echo "Creating worktree for: $task_name"

  # Create branch and worktree
  git worktree add -b $branch_name $worktree_path

  echo "âœ… Worktree created at: $worktree_path"
  echo "   Branch: $branch_name"
  echo "   To start Claude: cd $worktree_path && claude"
}

# Function to list worktrees
list_worktrees() {
  echo "Active worktrees:"
  git worktree list
}

# Function to cleanup worktree
cleanup_worktree() {
  local task_name=$1
  local worktree_path="$WORKTREE_BASE/$task_name"

  echo "Removing worktree: $task_name"
  git worktree remove $worktree_path

  # Optionally delete branch
  read -p "Delete branch feature/$task_name? (y/n) " -n 1 -r
  echo
  if [[ $REPLY =~ ^[Yy]$ ]]; then
    git branch -D "feature/$task_name"
  fi
}

# Main command handler
case "$1" in
  create)
    create_worktree "$2"
    ;;
  list)
    list_worktrees
    ;;
  cleanup)
    cleanup_worktree "$2"
    ;;
  *)
    echo "Usage: $0 {create|list|cleanup} [task-name]"
    echo ""
    echo "Examples:"
    echo "  $0 create metrics-dashboard"
    echo "  $0 list"
    echo "  $0 cleanup metrics-dashboard"
    exit 1
    ;;
esac
```

**Example Workflow**:
```bash
# Terminal 1: Create worktree for authentication refactor
./scripts/setup-worktrees.sh create auth-refactor
cd ../experimentation-platform-worktrees/auth-refactor
claude
# Prompt: "Refactor authentication system to use JWT with refresh tokens"

# Terminal 2: Create worktree for metrics dashboard
./scripts/setup-worktrees.sh create metrics-dashboard
cd ../experimentation-platform-worktrees/metrics-dashboard
claude
# Prompt: "Build real-time metrics dashboard with WebSocket updates"

# Terminal 3: Create worktree for API rate limiting
./scripts/setup-worktrees.sh create rate-limiting
cd ../experimentation-platform-worktrees/rate-limiting
claude
# Prompt: "Implement Redis-based rate limiting for all API endpoints"

# Work proceeds in parallel, then merge when ready
```

---

### 2.3 Headless Mode with Custom Harness

#### Pattern A: Fan-Out for Large Migrations

**Use Case**: Migrate 100+ test files from pytest to use new fixture patterns.

**Implementation** (`scripts/migrate-tests-fanout.sh`):
```bash
#!/bin/bash
# Fan-out test migration using Claude headless mode

# Step 1: Generate task list
echo "Generating migration task list..."
claude -p "Analyze backend/tests/ directory.
Create a list of all test files that need migration to new fixture patterns.
Return JSON array:
[
  {\"file\": \"path/to/test.py\", \"complexity\": \"simple|moderate|complex\"},
  ...
]
" --output-format stream-json > migration-tasks.json

TOTAL_TASKS=$(jq '. | length' migration-tasks.json)
echo "Found $TOTAL_TASKS files to migrate"

# Step 2: Process each task in parallel
SUCCEEDED=0
FAILED=0

process_migration() {
  local file=$1
  local complexity=$2

  echo "Migrating: $file (complexity: $complexity)"

  RESULT=$(claude -p "Migrate $file to use new fixture patterns.

Requirements:
1. Replace old @pytest.fixture with new patterns
2. Update imports for new fixtures
3. Ensure all tests still pass
4. Maintain test coverage

When done, return:
- 'OK' if migration succeeded and tests pass
- 'FAIL: <reason>' if migration failed

Run tests after migration to verify." \
  --allowedTools Edit Bash \
  --output-format stream-json \
  --verbose 2>&1)

  if echo "$RESULT" | grep -q "OK"; then
    echo "âœ… Success: $file"
    return 0
  else
    echo "âŒ Failed: $file"
    echo "$RESULT" >> migration-failures.log
    return 1
  fi
}

# Export function for parallel execution
export -f process_migration

# Process tasks in parallel (8 at a time)
jq -r '.[] | "\(.file) \(.complexity)"' migration-tasks.json | \
  xargs -P 8 -I {} bash -c 'process_migration {}'

# Report results
echo ""
echo "Migration Summary:"
echo "  Total: $TOTAL_TASKS"
echo "  Succeeded: $SUCCEEDED"
echo "  Failed: $FAILED"

if [ $FAILED -gt 0 ]; then
  echo ""
  echo "Failed migrations logged to: migration-failures.log"
  echo "Review and retry these manually."
fi
```

#### Pattern B: Pipeline Integration

**Use Case**: Process experiment results through Claude for insight generation.

**Implementation** (`scripts/analyze-experiments-pipeline.sh`):
```bash
#!/bin/bash
# Pipeline: Fetch experiment data â†’ Claude analysis â†’ Report generation

# Step 1: Fetch experiment results
echo "Fetching experiment results..."
python scripts/export-experiment-results.py > raw-results.json

# Step 2: Claude analyzes results
echo "Analyzing with Claude..."
cat raw-results.json | \
  claude -p "Analyze these experiment results.

For each experiment, determine:
1. Statistical significance (yes/no with confidence level)
2. Winner variant (or 'no clear winner')
3. Key insights (3-5 bullet points)
4. Recommendations (continue/iterate/stop)
5. Potential confounding factors

Return JSON format for programmatic processing:
{
  \"experiment_id\": \"...\",
  \"significant\": true,
  \"winner\": \"variant_b\",
  \"confidence\": 0.95,
  \"insights\": [...],
  \"recommendation\": \"continue\",
  \"confounds\": [...]
}
" --output-format stream-json > analyzed-results.json

# Step 3: Generate report
echo "Generating report..."
python scripts/generate-experiment-report.py analyzed-results.json > reports/experiment-analysis-$(date +%Y%m%d).md

# Step 4: Update dashboard
echo "Updating dashboard..."
python scripts/update-dashboard.py analyzed-results.json

echo "âœ… Pipeline complete"
echo "Report: reports/experiment-analysis-$(date +%Y%m%d).md"
```

---

## Implementation Timeline

### Week 1: Foundation
- [ ] Set up GitHub Actions for issue triage
- [ ] Create claude-lint.sh script
- [ ] Test headless mode locally
- [ ] Document headless patterns in CLAUDE.md

### Week 2: Multi-Claude Workflows
- [ ] Create git worktree helper scripts
- [ ] Implement multi-Claude review workflow
- [ ] Test parallel development scenarios
- [ ] Create scratchpad communication pattern

### Week 3: Advanced Automation
- [ ] Implement fan-out migration harness
- [ ] Create pipeline integration examples
- [ ] Set up CI integration for Claude linter
- [ ] Performance testing for parallel execution

### Week 4: Refinement & Documentation
- [ ] Optimize prompts based on results
- [ ] Add monitoring and metrics
- [ ] Create comprehensive documentation
- [ ] Train team on new workflows

---

## Success Metrics

### Headless Mode Automation
- **Issue Triage**: 90% of issues auto-labeled correctly
- **Linter Adoption**: 50% of PRs show subjective improvements
- **Time Savings**: 5 hours/week saved on manual code review

### Multi-Claude Workflows
- **Parallel Development**: 3x more features developed simultaneously
- **Code Quality**: 30% reduction in post-merge bugs
- **Review Efficiency**: 40% faster code review cycles

### Overall Impact
- **Developer Velocity**: 2x increase in feature delivery
- **Code Coverage**: Maintain 70%+ test coverage
- **Team Satisfaction**: 8/10 rating on new workflow tools

---

## Next Steps

1. **Review this plan** with the team
2. **Prioritize** which automations to implement first
3. **Set up** development environment for headless mode
4. **Create** prototype scripts for highest-impact workflows
5. **Iterate** based on team feedback

---

## Resources

- [Claude Code Best Practices](https://www.anthropic.com/engineering/claude-code-best-practices)
- [GitHub Actions Documentation](https://docs.github.com/en/actions)
- [Git Worktrees Guide](https://git-scm.com/docs/git-worktree)
- [Headless Mode Examples](https://docs.claude.com/claude-code/headless)

---

**Questions or suggestions?** Add comments to this document or discuss in team meetings.
